# Reactor 맛보기

### 의존성
```xml
<dependency>
    <groupId>org.reactivestreams</groupId>
    <artifactId>reactive-streams</artifactId>
    <version>1.0.3</version>
</dependency>
```


# 
webflux.

Reactor라는게 있음.
스프링에도 라이브러리가 있음. 우리가 쓰는건 스프링4.0

기능은 구독과 출판. 
스프링 5.0버전부터는 Reactor가 들어가있음.

MVC + Spring + JPA => 신규

부산에서는 레거시 + myBatis


오늘은 Reactor를 할꺼임.

Reactor란 JVM기반의 논블록킹 어플리케이션을 만들기위한 라이브러리. 지금까지 우리가 만든건 쓰레드기반.
 
논블로킹 -> 라면끓이다가 전화오면 받을 수 있음.

Flux = > 스트림과 비슷한 의미가 있음. 

모노와 플럭스의 차이
모노는 리스폰스하고 연결을 끊어버리는거고 플럭스는 리스폰스선을 유지하고있음. 

reactivestreams 라이브러리의 원리

출판사(퍼블리셔)

구독자(서브스크라이버)

구독정보(서브스크립션)

원래는 구독자가 요청을해야 출판사가 응답을해주는게 일반적인 구조임
그런데 구독자가 구독정보를 출판사한테 넘겨주면 (구독정보는 서브스크립션에 들어감 ex.음악관련 1년)
구독 정보를 바탕으로 해서 구독자한테 응답을해줄껀데 언제 업데이트 해줄꺼냐면 뭔가 변경이 일어나거나 업데이트 발행이되면 응답을 구독자에게 준다. 이때 출판사가 구독자의 구독정보 ex 음악관련구독2 운동1 이렇게잇으면 셋다 음악운동 다던져주고 구독자들이 가려서 받는데 -> 왜냐하면 브로드캐스팅 방식

maven에서 ReactiveStream 을 다운받음 1.0.3

기존의 Block방식에서는 스레드를 이용해서 timeslash를 했었음.
블락방식이라서 라면끓이면서 전화를 받고 계란을 넣어야하는 3가지 과정이 있다고 하자. 각가의 스레드로돌고잇는데, 만약1번에서 라면끓이다가 전화를 받으면 계란을 넣을 수 없음. 
2가 끝나기 전까지. 이런문제점을 해걀하기 위해서

=> 비동기 방식
이벤트 루프를 이용해서 이벤트루프에 라면끓이기라는걸 넣어줌. 끓을때까지 기다려야하니깐
그 밑에 전화받기를 하러감. 전화끝나고 이벤트루프를 뒤져봄. 
이벤트루프에서 라면이 다 끓었으면 이제 계란을 넣으러감.


Iterable의 hasNext는 데이터있으면 뿌려줌


구독자는 제일먼저 출판사한테 구독이라는 걸 제일 먼저 함. 
출판사는 구독자의 구독을 받아서 구독정보를 해석한다. 구독에 어떤내용이들어잇냐면 
홍길동, 구독하는갯수10개 뭐 이런식으로 이걸 구독자한테 돌려주면 
구독자가 백프레셔를 갯수로 신청함. 
구독자가 2개씩 달라고하면 onNext를 실행하면서 데이터를 2건씩 돌려줌. 언제까지? 데이터를 전부 다 보낼때 까지. 데이터가10개라고 하면 response가 5번이 일어남. 그리고 통신이 끝나버림.

하지만 웹에서는 이렇게 리스폰스가 다 일어나고 통신이 끊기면안됨! 리스폰스는 항상 연결 되어있어야함. 

그래서 프로세서가 필요함. onNext를 할떄 데이터베이스에 만약 데이터가 추가된다면? 그래서 싱크라는걸 상용한다. 싱크라는거는 추가된데이터까지 onNext를 계속 해줄수 있게 도와주는 친구.
=> 완전한 push서버가 일어남. 

우리는 프로세서를 사용해서 위의 개념을 그냥 "사용" 하기만 하면 된다.




